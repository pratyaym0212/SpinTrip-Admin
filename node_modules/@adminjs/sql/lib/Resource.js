import { BaseRecord, BaseResource, } from 'adminjs';
import { ResourceMetadata } from './metadata/index.js';
export class Resource extends BaseResource {
    static isAdapterFor(resource) {
        const r = resource instanceof ResourceMetadata;
        if (!r) {
            throw new Error('Resource must contain valid metadata.');
        }
        return r;
    }
    knex;
    dialect;
    propertyMap = new Map();
    tableName;
    schemaName;
    _database;
    _properties;
    idColumn;
    constructor(info) {
        super(info.tableName);
        this.knex = info.knex;
        this.schemaName = info.schemaName;
        this.tableName = info.tableName;
        this._database = info.database;
        this._properties = info.properties;
        this._properties.forEach((p) => {
            this.propertyMap.set(p.path(), p);
        });
        this.idColumn = info.idProperty.path();
        this.dialect = info.dialect;
    }
    databaseName() {
        return this._database;
    }
    // eslint-disable-next-line class-methods-use-this
    databaseType() {
        return 'Postgres';
    }
    id() {
        return this.tableName;
    }
    properties() {
        return this._properties;
    }
    property(path) {
        return this.propertyMap.get(path) ?? null;
    }
    async count(filter) {
        const [r] = await this.filterQuery(filter).count('* as cnt');
        return r.cnt;
    }
    async find(filter, options) {
        const query = this.filterQuery(filter);
        if (options.limit) {
            query.limit(options.limit);
        }
        if (options.offset) {
            query.offset(options.offset);
        }
        if (options.sort?.sortBy) {
            query.orderBy(options.sort.sortBy, options.sort.direction);
        }
        const rows = await query;
        return rows.map((row) => new BaseRecord(row, this));
    }
    async findOne(id) {
        const knex = this.schemaName
            ? this.knex(this.tableName).withSchema(this.schemaName)
            : this.knex(this.tableName);
        const res = await knex.where(this.idColumn, id);
        return res[0] ? this.build(res[0]) : null;
    }
    async findMany(ids) {
        const knex = this.schemaName
            ? this.knex(this.tableName).withSchema(this.schemaName)
            : this.knex(this.tableName);
        const res = await knex.whereIn(this.idColumn, ids);
        return res.map((r) => this.build(r));
    }
    build(params) {
        return new BaseRecord(params, this);
    }
    async create(params) {
        const knex = this.schemaName
            ? this.knex(this.tableName).withSchema(this.schemaName)
            : this.knex(this.tableName);
        await knex.insert(params);
        return params;
    }
    async update(id, params) {
        const knex = this.schemaName
            ? this.knex.withSchema(this.schemaName)
            : this.knex;
        await knex.from(this.tableName).update(params).where(this.idColumn, id);
        const knexQb = this.schemaName
            ? this.knex(this.tableName).withSchema(this.schemaName)
            : this.knex(this.tableName);
        const [row] = await knexQb.where(this.idColumn, id);
        return row;
    }
    async delete(id) {
        const knex = this.schemaName
            ? this.knex.withSchema(this.schemaName)
            : this.knex;
        await knex.from(this.tableName).delete().where(this.idColumn, id);
    }
    filterQuery(filter) {
        const knex = this.schemaName
            ? this.knex(this.tableName).withSchema(this.schemaName)
            : this.knex(this.tableName);
        const q = knex;
        if (!filter) {
            return q;
        }
        const { filters } = filter;
        Object.entries(filters ?? {}).forEach(([key, filter]) => {
            if (typeof filter.value === 'object'
                && ['date', 'datetime'].includes(filter.property.type())) {
                q.whereBetween(key, [filter.value.from, filter.value.to]);
            }
            else if (filter.property.type() === 'string') {
                if (this.dialect === 'postgresql') {
                    q.whereILike(key, `%${filter.value}%`);
                }
                else {
                    q.whereLike(key, `%${filter.value}%`);
                }
            }
            else {
                q.where(key, filter.value);
            }
        });
        return q;
    }
}
//# sourceMappingURL=Resource.js.map